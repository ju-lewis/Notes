


>[!cite] Note
A well designed representation using algebraic types is not vulnerable to runtime errors.


When implementing a 'Haskell-like' generic list in C, we must either use:
- Lots of casting from void pointers (unsafe)
- Many different implementations for different types (safe but results in duplicate code)


## Measurement Units

One typical bug in programs that manipulate measurements is unit confusion
- e.g. adding 2 feet to 3 metres

Such bugs can be prevented by wrapping the number representing the length in a data constructor giving its unit

**Example**
```haskell
data Length = Meters Double

meters_to_length :: Double -> Length
meters_to_length m = Meters m

feet_to_length :: Double -> Length
feet_to_length f = Meters (f * 0.3048)
```

We can now safely manipulate the measurements as `Length`s, with the guarantee that there'll be no mismatches.


## Different Uses of One Unit

Sometimes, you want to prevent confusion event between two kinds of quantities measured in the same units. (e.g. seconds to measure a change in time *vs* seconds to measure time since Unix epoch)

```haskell
data Duration = Seconds Int
data Time = SecondsSinceEpoch Int

add_durations :: Duration -> Duration -> Duration

add_duration_to_time :: Duration -> Time -> Time
```


Sometimes you cannot apply a fixed conversion rate between different units (e.g. *currency conversion*)
- Note: don't use `Double`s for currency


## Mapping over a `Maybe`

Given the type
```haskell
type Marks = Map String [Int]

-- We can aggregate student marks with the function:
studentTotal :: Marks -> String -> Maybe Int
studentTotal marks student = 
		case Map.lookup student marks of
			Nothing -> Nothing
			Just ms -> Just (sum ms)
```

The definition of out `studentTotal` function is quite verbose, requiring the unwrapping and re-wrapping of the `Maybe` type.


### The `Functor` Type Class

We can think of `Maybe` as a "box" that *might* hold a value of type `a` (or could be empty)

We want to apply a function *inside* the box, leaving the box in place but replacing its content with the result of the function.



The `Functor` type class is the class of all types that can be *mapped over*
- Including `List`s and `Maybe`

For a type to be in `Functor`, it must implement 
`fmap :: Functor f => (a -> b) -> f a -> f b`

This gives us a much more succinct definition to the `studentTotal` function:
```haskell
studentTotal :: Marks -> String -> Maybe Int
studentTotal marks student = 
	fmap sum (Map.lookup student marks)
```

The standard prelude also defines `<$>` as an infix operator alias for `fmap`

```haskell
studentTotal marks student = sum <$> (Map.lookup student marks)
```



### Beyond Functors

What if we want to aggregate the marks of 2 students (e.g. if they work in pairs but only 1 student submits each assignment)

**Simple (Verbose) Solution**
	We could simply check the first student lookup isn't `Nothing`, then obtain their mark sum, then check the second student lookup isn't `Nothing` and return their mark sum.


**Using Functors**

The first step of this 

We can't simply use `fmap` from the `Functor` type class, as there are 2 'layers' of `Maybe`s to deal with!
- So we need a way to extract a function from inside a functor and `fmap` that over another functor
	- *We want to apply one functor to another*


>[!note]
>`Functor` works extremely well for unary functions (e.g. `sum`) but not for greater arities, as the partial application of a binary (or higher arity) function to a value within a functor results in a wrapped function (e.g. `Maybe (int -> int)`) as the partial application may not have been valid/successful.


### `Applicative` Functors

An applicative functor is a functor that can contain functions - which are applied to other functors.

The most important function in the `Applicative` type class is:
```haskell
-- (<*>) takes a functor containing a function and applies the wrapped
-- function to the second Functor argument.
(<*>) :: f (a -> b) -> f a -> f b
```


`Maybe` is a member of the `Applicative` type class, so we can define our `pairTotal` function as follows:


```haskell
pairTotal :: Marks -> String -> String -> Maybe Int
pairTotal marks student1 student2 = 
	-- Partially apply our original function `studentTotal`
	-- mark takes a student and returns (maybe) the sum of their marks
	let mark = studentTotal marks 
	in 
		-- We apply (+) to a Maybe Int, resulting in Maybe (Int -> Int)
		-- Then <*> applies the function with the Functor on the left
		((+) <$> mark student1) <*> student2
```


`Applicative` defines a second function:
```haskell
pure :: a -> f a
```

Which simply inserts a value into an applicative functor.

**Examples**
For the `Maybe` type, `pure = Just`
For lists, `pure = (:[])` (creates a singleton list)


>[!note]
>Every `Applicative` must also be a `Functor`. (Like every `Ord` must be in `Eq`)


#### Example

If we wanted to subtract a student's score from 100, we could do the following:

```haskell
-- We first partially apply the subtraction operator to a pure functor
-- containing `100`.
-- We then use an Applicative map to apply the function within the resulting
-- applicative functor to the functor returned by studentTotal
( (-) <$> pure 100 ) <*> studentTotal marks student
```


This can be done more simply by just partially applying the subtraction operator before wrapping it in a Functor
```haskell
(100-) <$> studentTotal marks student
```


Remember, `fmap` takes a function and applies it to the value within a `Functor`, returning a function containing the result.


